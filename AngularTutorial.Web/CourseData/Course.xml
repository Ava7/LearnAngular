<?xml version="1.0" encoding="utf-8" ?>
<Course xmlns="http://angulartutorial.azurewebsites.net/Course.xsd">
  <Module Id="module-getting-started" Title="Getting Started">
    <Lesson Id="introducing-angular" Title="Introducing AngularJS">
      <Instructions>
        <![CDATA[
So, you want to learn AngularJS. Great! Let's jump right in.

##What is AngularJS?
AngularJS is a JavaScript framework that is used for making rich, extensible web applications. It runs on plain JavaScript and HTML, so you don't need any other dependencies to make it work, and it is CSS-agnostic so you can use whatever CSS framework/methodology you want when designing your Angular application.

Now, if you go out ask five different developers why Angular is so great you'll probably get five different answers. For my money though, there are three key features that make it a really great framework to work with.

1. **Data binding** - Data binding is the ability to "bind" variables and functions from your code into your user interface and have changes in one side update the other. For example, you can display a JavaScript variable in a form field, and if the user changes the value, the value in JavaScript will automatically update to reflect the change. No more `onchanged` events required to keep things in sync in cases like this! If you've ever used KnockoutJS or a similar framework you'll be ahead of the game learning Angular. And If you haven't, you'll bei thoroughly amazed at how data binding makes your life easier.

2. **The integrated framework** - Angular provides built-in functions to automate a lot of common tasks, such as making Ajax calls. As such, you can often code Angular apps without having to include additional libraries such as jQuery. Angular actually includes a built-in subset of jQuery, called "jQuery lite". That said, if you want to include jQuery in your apps, no problem! Angular will detect the presence of jQuery and adapt accordingly.

3. **SPAs** - Angular makes writing single page applications really easy! This site is an example of a single page application. When you change lessons or click on links, you'll notice that the page content updates without requiring a refresh. At the same time however, the url in the browser's navigation bar updates accordingly which allows you to use the browser's forward and back buttons to navigate, as well as to bookmark a page and return to it later.

These three features along with many, many more make Angular a very powerful framework for developing web applications. Now then, enough chatter, let's move forward and take a look at how an Angular application is built.
      ]]>
      </Instructions>
    </Lesson>
    <Lesson Id="the-essentials" Title="The Essentials">
      <Instructions>
        <![CDATA[
Now that you have an idea of what AngularJS is all about, let's start looking at what makes up an AngularJS application. Angular applications at their most basic consist of three components.

+ The template (view)
+ The scope
+ The controller

##The template

The template is the HTML portion of the app. Writing a template is exactly like writing a static HTML page, except that templates contain additional syntax which allows data to be injected into them in order to provide a customized user experience. If you have ever written an HTML page using a server-side web framework you'll feel right at home writing templates in Angular. The feature that differentiates Angular templates from server-generated pages, however, is that in Angular data can be injected, modified and removed from templates without ever requiring a page refresh. This feature provides a more fluid experience to the end user and enhances the overall feel of Angular web applications.

##The scope

The scope is a very important component in Angular applications. The scope is the object that represents the "model" of your application. It contains fields that store data which is presented to the user via the template, as well as functions which can be called when the user performs certain actions such as clicking a button.

##The controller

The controller plays somewhat of a supporting role in Angular applications. The controller is a function which generally takes an empty scope object as a parameter and adds to it the fields and functions that will be later exposed to the user via the view.

##Relation to MVC
Up until now I have intentionally tried to stay away from making any comparisons between Angular and MVC for the benefit of those who have not worked with the MVC pattern before. If you have worked with MVC, then you probably won't need any help in identifying how closely Angular's architecture resembles that of an MVC-based application. As the two are so closely linked, I may from here on in refer to the template as the "view" and the scope as the "model". If you are unfamiliar with MVC, just be aware that these terms are interchangeable and that I am not talking about anything that you haven't seen before.

##Summary
The template, the scope, and the controller are the three main building blocks of an Angular web application. While there is much more to Angular than these three components, with an understanding of what they do and how they interact you will already be capable of wiring together a simple Angular application.
      ]]>
      </Instructions>
    </Lesson>
    <Lesson Id="a-simple-app" Title="A Simple App">
      <Instructions>
        <![CDATA[
*These lessons are intended to be interactive. Follow along in the code pages on the right as we go!*

---

Now that we have a basic understanding of what Angular is all about and how an application fits together, let's jump right in and integrate Angular into a simple web page.

##Writing the controller
For this lesson we are starting out with a very basic web page which contains a single, empty `<div>`. Let's use Angular to insert the text "Hello World" dynamically into the page.

The first thing that we need to do is define our controller. Remember, the controller is a function which augments the scope with data, functions, and whatnot.

To define our controller we first need to define what is known as a *module*. We didn't discuss modules in the last lesson, but no need to worry; they are extremely simple to understand. Modules act as logical containers for components in Angular applications. Whenever we define a component such as a controller, it needs to go in a module. The syntax for defining a module is as follows.

	angular.module("root", [])

That's all there is to it! The first argument, the string, defines the name of the module, which in this case is `root`. The second argument, the empty array, is used for dependency injection. We aren't going to get into Angular's dependency injection mechanism quite yet, but if you are unfamiliar with the concept of DI I strongly  recommend that you at least get acquainted with the concept before continuing on.*

Anyways, in this example we don't need to inject any dependencies into our module, so the array is empty. Now, I must stress the following point because it is a common place for beginners to trip up when declaring modules. **Do not forget the empty array**. If you forget it, Angular will try to retrieve an existing module for you instead of instantiating a new one and an error will be thrown.

Anyways, now that we have declared our module we can move on to declaring our controller. We declare our controller directly on the module that we have just created by using the `controller()` function like so.

	angular.module("root", [])
		.controller("controller", ["$scope", function($scope) {
			
		}]);

The controller function syntax is much like the module syntax. The first argument specifies the name of the controller we are declaring. The second argument is an array whose last argument is a function. This is the controller function that we will use to augment our scope.

The elements in the array that precede the controller function are the names of the dependencies that we will  pass to the function as arguments. In this case, we are passing the `$scope` dependency into the controller. This is the scope to which we will add our functions and variables in just a moment. It is important to note that the order of dependencies in the array must match the order of the function arguments.

##Augmenting the $scope

Now that our controller function is defined, we can start working on the `$scope`. Let's define a variable named `message` which will contain the string `Hello World!`

	angular.module("root", [])
		.controller("controller", ["$scope", function($scope) {
			$scope.message = "Hello World";
		}]);

Great. Now all we need to do is wire up our template to display this value in the empty `div`.

##Putting it all together.

Let's turn our attention to our HTML. For now we just have a simple page. We need to do five things to wire in Angular.

1. Include a reference to the Angular script file.
2. Include a reference to our controller script file.
3. Tell Angular which module we are using as our "root module"
4. Tell Angular to what part of the page it should apply our controller and the corresponding scope.
5. Tell Angular to display our message in the `<div>`.

For this lesson and throughout this entire site in fact, I have already taken care of steps 1 and 2 for you behind the scenes. In upcoming lessons I will often take care of step 3 for you as well. However in this lesson steps 3, 4, and 5 are up to you!

###The root module

In Angular-speak, the "root module" is the base module for the application. In our case we only have one module so the selection process is easy. We need to tell Angular that we want the `root` module to be our root. We do this by adding what is known as a *directive* to the `html` element of the page. You'll be hearing a lot about directives as we go on. Directives are essentially instructions that we use to tell Angular what we want it to do.

The directive we need to apply is the `ngApp` directive. We apply this directive to the HTML element in the form of an attribute, like so.

	<html ng-app="root">

There are a couple things to note here.

+ The directive name is `ngApp` but it is applied in the form of an attribute named `ng-app`. We'll discuss the intricacies of this syntax in a later lesson, but for now just understand that directives are given names in camelCase but are written in hyphen-delimited lowercase when applied as attributes.

+ The value of the attribute is the name of our root module.

That's all we need to do. Angular now understands that the module named `root` is the root module for the application.

###The controller

We now need to apply our controller to the page. We apply the controller using the `ngController` directive. The element to which we apply the `ng-controller` attribute is important. This element and all its children will be able to access the `$scope` object augmented by the controller.

For this lesson, we are going to apply the directive to the `div` element like so.

	<div ng-controller="controller"></div>

###Accessing the scope

All that's left to do is display our message in the page! To print a variable value in our template, we use the double curly brace syntax, specifying the name of the `$scope` variable we wish to print.

	{{message}}

Add this syntax to the `<div>` element on which we applied our controller and run the code. If all is well, you should see `Hello World` printed loud and clear onto the page for all to see! If something went wrong, don't worry. You can either see the answer by clicking on the "I'm stuck!" button, or reset the example altogether and start over.

##Expressions
Now that you've seen how to bind a scope value to the template, try this. Replace `{{message}}` with a mathematical equation such as `{{1 + 1}}` and run the application. You'll see that Angular will have evaluated the equation and printed the result! This is because the value inside the curly braces is considered by Angular to be an *expression*. Expressions are like simple JavaScript statements, which means that in addition to supporting `$scope` fields, they also support simple functions like this one. Details of exactly what is and is not supported by Angular expressions can be found [here on the Angular site](http://docs.angularjs.org/guide/expression).

##Summary
We learned a lot this lesson! We learned about modules, how to declare controllers, and most importantly how to wire everything together to make a full-fledged application. While we haven't seen anything very impressive in terms of results, don't worry because we're getting there. In the next set of lessons we'll take a deeper look at directives and how they can enrich Angular applications.

---

*[Dependency injection for five year olds](http://stackoverflow.com/a/1638961/1068266) is a good place to start if you are completely unfamiliar with the concept, after which there is [this explanation which is simple and to the point](http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html).
      ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Initial>
            <![CDATA[
<!DOCTYPE html>
<html>
    <body>
        <div></div>
    </body>
</html>
          ]]>
          </Initial>
          <Solution>
            <![CDATA[
<html ng-app="root">
    <body>
        <div ng-controller="controller">{{message}}</div>
    </body>
</html>
          ]]>
          </Solution>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module('root', [])
    .controller('controller', ["$scope", function ($scope) {
        $scope.message = "Hello World!";
    }]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <Module Id="module-basic-directives" Title="Basic Directives">
    <Lesson Id="two-way-bindings" Title="Two-way bindings">
      <Instructions>
        <![CDATA[
In this section we are going to take a look at some basic directives that you can use to add interactivity and flexibility to your web applications. There is a lot more to the Angular framework than we have just seen, but looking at a few directives right away will give you an idea of what you can do with Angular and hopefully inspire you to lean more about the framework in the sections that follow.

##ngModel

We're going to start out by looking at one of the most important directives in Angular, `ngModel`. Unlike values bound using the double curly brace syntax, `ngModel` allows us to bind values to HTML elements such as input fields. When using `ngModel`, not only are changes in the scope reflected in the view, but changes in the view are reflected back into the scope.

To see `ngModel` in action, we are going to use it to bind the `favoriteWord` field in the scope to the input field in the HTML page. To do this, we simply need to apply `ngModel` to the input field in the form of an attribute like so.

`<input type="text" ng-model="favoriteWord" />`

As you can see, `ngModel` takes an expression which is almost always the name of the `$scope` field to which we want to bind our element. Now, go ahead and try binding the other two scope variables to their respective input fields. As a reminder, remember that radio button values are retrieved from each individual `<input>` tag, and that drop-down values are retrieved from the all-encompassing `<select>` tag.

Once the values are bound, use the double curly brace syntax to display each value next to its corresponding input and run the example to see two-way binding in action!
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
  <body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="controller">
	<div>
		Favorite number: <input type="text" />
		- [Display selection here]
	</div>
	<div>
		Favorite color:
		<input type="radio" name="fc" value="Red">Red</input>
		<input type="radio" name="fc" value="Green">Green</input>
		<input type="radio" name="fc" value="Yellow">Yellow</input>
		<input type="radio" name="fc" value="Blue">Blue</input>
		- [Display selection here]
	</div>
	<div>
		Favorite shape:
		<select>
			<option value="Circle">Circle</option>
			<option value="Triangle">Triangle</option>
			<option value="Square">Square</option>
		</select>
		- [Display selection here]
	</div>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="controller">
	<div>
		Favorite word: <input type="text" ng-model="favoriteWord" />
		- {{favoriteWord}}
	</div>
	<div>
		Favorite color:
		<input type="radio" name="fc" value="Red" ng-model="favoriteColor">Red</input>
		<input type="radio" name="fc" value="Green" ng-model="favoriteColor">Green</input>
		<input type="radio" name="fc" value="Yellow" ng-model="favoriteColor">Yellow</input>
		<input type="radio" name="fc" value="Blue" ng-model="favoriteColor">Blue</input>
		- {{favoriteColor}}
	</div>
	<div>
		Favorite shape:
		<select ng-model="favoriteShape">
			<option value="Circle">Circle</option>
			<option value="Triangle">Triangle</option>
			<option value="Square">Square</option>
		</select>
		- {{favoriteShape}}
	</div>
</div>      
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
  </body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
    .controller("controller", ["$scope", function($scope) {
        $scope.favoriteWord;
        $scope.favoriteColour;
        $scope.favoriteShape;
    }]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
    .controller("controller", ["$scope", function($scope) {
        $scope.favoriteWord;
        $scope.favoriteColour;
        $scope.favoriteShape;
    }]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="binding-css-classes" Title="Binding CSS classes">
      <Instructions>
        <![CDATA[
Just as Angular lets us bind scope values to input fields, it also allows us to bind scope values as class names to HTML elements. As you can imagine, this feature is extremely useful and probably one of the most used features in Angular altogether.

##ngClass

To bind a CSS class to an HTML element, we use the `ngClass` directive. `ngClass` takes as input an expression which must evaluate to one of the following.

+ A string of space-delimited class names.
+ An array of class names.
+ A map (object) where the keys are class names and the values are boolean values indicating whether or not to apply the class.

##Example

For this demo, I've defined three CSS classes for you behind the scenes:

+ `bold`
+ `italic`
+ `underline`

Let's try applying these three classes to the `span` of sample text in the HTML window according to the following logic:

+ If the value in the textbox % 2 == 0, apply `bold`.
+ If the value in the textbox % 3 == 0, apply `italic`.
+ If the value in the textbox % 5 == 0, apply `underline`.

For this example, let's try to do this with a map.

We'll start by defining a function for each of the criteria in the controller.

	$scope.isBold = function () { return $scope.value % 2 === 0; };
	$scope.isItalic = function () { return $scope.value % 3 === 0; };
	$scope.isUnderlined = function () { return $scope.value % 5 === 0; };

Now, let's apply the `ngClass` directive to the span of text in the form of an attribute, and pass it a map of class names and boolean values.

	ng-class="{bold: isBold(), italic: isItalic(), underline: isUnderlined()}

Once applied, run the program. When you change the number in the text field, the classes applied to the sample text should change accordingly.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
<head>
<style>
.bold {
	font-weight: bold;
}
.italic {
	font-style: italic;
}
.underline {
	text-decoration: underline;
}
</style>
</head>
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="controller">
  <input type="text" ng-model="value" />
  <span>Example Text</span>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="controller">
  <input type="text" ng-model="value" />
  <span ng-class="{bold: isBold(), italic: isItalic(), underline: isUnderlined()}">
	  Example Text
  </span>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function ($scope) {
		$scope.value = 1;
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function ($scope) {
		$scope.value = 1;
		$scope.isBold = function () { return $scope.value % 2 === 0; };
		$scope.isItalic = function () { return $scope.value % 3 === 0; };
		$scope.isUnderlined = function () { return $scope.value % 5 === 0; };
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="repeaters" Title="Repeaters">
      <Instructions>
        <![CDATA[
It often happens that you need to display a collection of data to the user. For this task, Angular provides you with the `ngRepeat` directive. `ngRepeat` gives you the power to define a template for a single item in a collection, and then have it be repeated for all the elements in a collection.

The syntax for `ngRepeat` is super easy. In attribute form, it looks like this.

`ng-repeat="element in collection"`

Where `collection` is a collection in scope and `element` is a variable used to reference each element throughout the iteration.

In addition to this, Angular exposes several variables that allow you to gain information about the element currently being iterated on.

+ `$index` - The index of the current element.
+ `$first` - Boolean indicating if the element is the first in the collection.
+ `$middle` - Boolean indicating if the element is neither first nor last in the collection.
+ `$last` - Boolean indicating if the element is the last in the collection.
+ `$even` - Boolean indicating if the element's index is even.
+ `$odd` - Boolean indicating if the element's index is even.

These variables can be used freely within the scope of the iteration.

##Example

For this example, I've gone ahead and defined the CSS class `oddRow` behind the scenes. `oddRow` will change the background color of the element to which it is applied to a light gray color. What we're going to do in this example is populate the HTML table which is currently empty with the list of products defined in `root.js`.

The first thing to do is to define what we want one row of the table to look like. Let's do that now, filling in the empty `<tbody>` tag with a single row.


	<tbody>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</tbody>

Great. Now let's add the repeat directive. It is important to understand that `ngRepeat` will repeat *itself and its contents* for each element in the collection. We must therefore apply it to the `<tr>` and not the `<tbody>`.

	<tbody>
		<tr ng-repeat="product in products">
			<td></td>
			<td></td>
		</tr>
	</tbody>

Let's now go ahead and populate the cells with the values from the collection objects.

	<tr ng-repeat="product in products">
		<td>{{product.id}}</td>
		<td>{{product.name}}</td>
	</tr>

Almost done! Now let's apply the `oddRow` class to every odd-indexed `<tr>`. We'll need to use the `ngClass` directive that we learned about in the last lesson for this.

	<tr ng-repeat="product in products" ng-class="if ($odd) { return "oddRow"; }">
		<td>{{product.id}}</td>
		<td>{{product.name}}</td>
	</tr>

We're done! Run the program and check out the results!
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
<head>
<style>
.oddRow { background-color: #EEE; }
table { border-spacing: 0; }
td { border: 1px solid black; padding: 0 1em 0 1em; }
</style>
</head>
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="controller">
  <table>
	  <thead>
		  <tr>
			  <td>Id</td>
			  <td>Name</td>
		  </tr>
	  </thead>
	  <tbody>
	  </tbody>
  </table>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="controller">
  <table>
	  <thead>
		  <tr>
			  <td>Id</td>
			  <td>Name</td>
		  </tr>
	  </thead>
	  <tbody>
		  <tr ng-repeat="product in products"
			  ng-class="{oddRow: $odd}">
			  <td>{{product.id}}</td>
			  <td>{{product.name}}</td>
		  </tr>
	  </tbody>
  </table>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function($scope) {
		$scope.products = [
			{id: 1, name: "Hockey puck"},
			{id: 2, name: "Golf club"},
			{id: 3, name: "Baseball bat"},
			{id: 4, name: "Lacrosse stick"}
		];
}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function($scope) {
		$scope.products = [
			{id: 1, name: "Hockey puck"},
			{id: 2, name: "Golf club"},
			{id: 3, name: "Baseball bat"},
			{id: 4, name: "Lacrosse stick"}
		];
}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="visibility" Title="Visibility">
      <Instructions>
        <![CDATA[
##Showing and hiding

We've already seen that Angular lets you bind CSS classes to elements by way of the `ngClass` directive. However if you simply want to show or hide an element, there is a shortcut. The `ngShow` and `ngHide` directives display or hide an element from view by manipulating its `display` CSS property. They both take an expression as an argument which is expected to return a Boolean value.

##Adding and removing

If `ngShow` and `ngHide` control visibility, `ngIf` controls *existence*. That is to say that instead of simply altering how elements are displayed, `ngIf` adds and removes them from the DOM altogether. There are three important things to be aware of when using `ngIf`.

+ Code that performs calculations based on the position of elements in the DOM will behave differently with `ngIf` as opposed to `ngShow` or `ngHide`, as the latter two leave hidden elements in the DOM.

+ State is not preserved when Angular adds/removes elements from the DOM using `ngIf`. Elements that are removed from and then readded to the DOM are regenerated by Angular and reappear in their initial state, not the state that they were in when they were first removed.

+ Elements inserted with `ngIf` live in their own scope which inherits from their parent element's scope. In simple terms, this means that applying `ngIf` to an element is like applying a second `controller` directive. You will have access to the same fields as in the parent, but they will reside on a separate scope object. You therefore cannot rely on variables in one scope to remain synchronized with those in the other scope.*

##Example

For this example we're going to hook in the visibility of two `<div>` elements to two fields in our `$scope`. The fields are already declared for you, and two checkboxes are present to allow you to set each value. Try applying `ng-show="isFirstElementVisible"` to the first `<div>` and its `ngIf` equivalent to the second `<div>`. Then run the example and test it out. If you wish, you can take a look at the corresponding HTML for the document using your browser's development tools to see how `ngIf` and `ngShow` hide the elements to which they are applied.

---

*To see this in action, try pasting the following code into the editors and modifying the textbox values.

HTML:

	<div ng-controller="controller">
		<input type="text" ng-model="message" />
		{{message}}
		<div ng-if="true">
			<input type="text" ng-model="message" />
			{{message}}
		</div>
	</div>

JavaScript:

	angular.module("root", [])
		.controller("controller", ["$scope", function($scope) {
			$scope.message = "Hello World";
		}]);
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="controller">
  <div><input type="checkbox" ng-model="isFirstElementVisible" /> Is first element visible</div>
  <div><input type="checkbox" ng-model="isSecondElementVisible" /> Is second element visible</div>
	<div>First Element</div>
	<div>Second Element</div>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="controller">
  <div><input type="checkbox" ng-model="isFirstElementVisible" /> Is first element visible</div>
  <div><input type="checkbox" ng-model="isSecondElementVisible" /> Is second element visible</div>
	<div ng-show="isFirstElementVisible">First Element</div>
	<div ng-if="isSecondElementVisible">Second Element</div>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function($scope) {
		$scope.isFirstElementVisible = true;
		$scope.isSecondElementVisible = true;
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function($scope) {
		$scope.isFirstElementVisible = true;
		$scope.isSecondElementVisible = true;
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <Module Id="module-core-facilities" Title="Core Facilities">
    <Lesson Id="handling-complexity" Title="Handling Complexity">
      <Instructions>
        <![CDATA[
As Angular applications begin to grow bigger and more complex, the time inevitably comes when we want to externalize some of the logic contained in our controllers into outside objects. Angular provides us with two key features that work hand in hand to help us do just this: dependency injection and services.

###Dependency injection
Dependency injection is a central part of Angular application development. It is so central, in fact, that we have been using it since the very first example. Every time that we declare a controller with a `$scope` we are using Angular's internal dependency injection mechanism.

	.controller("controller", ["$scope", function ($scope) {
		// $scope is dependency-injected!
	}]);

What is so special about this is that we do not invoke the controller function, passing it an argument. Angular does! Angular's injector sees from the `"$scope"` array element that we want the first (and only) function argument to be an instance of `$scope`, and Angular makes it so this is the case.*

###Services
In an Angular app, services are logical application components that are wired together using dependency injection. They allow us to externalize application logic out of controllers and encapsulate it in easy to use containers. Angular ships with a number of built-in services that allow us to do things like perform Ajax requests or change the URL in the browser's address bar, but the real power of services is the ability to write our own. The following five lessons cover each of these recipes, an

Angular defines five different service types, or "recipes". Each recipe results in a service which has special characteristics that make it useful for solving a certain type of problem. The following five lessons cover each one of these recipes in detail.

Ready to get started? 

---

*You may be wondering why we need this somewhat clumsy array syntax. Shouldn't Angular be able to detect that we want a `$scope` based on the name of the function argument? The reason why we use this syntax is because it allows the Angular injector to work properly when the JavaScript is minified. Minification alters variable names, but not strings.
        ]]>
      </Instructions>
    </Lesson>
  <Lesson Id="the-value-recipe" Title="The value recipe">
      <Instructions>
        <![CDATA[
The value recipe is the simplest service recipe of all. A value service does exactly what you would expect it to. It provides a value! While this may sound like a trivial task, many applications can benefit from integrating value services into their architecture. Small applications can use value services to decouple "magic number" type values from controller implementations, and larger applications can use value services to marshal data between controllers.

The syntax for defining a value is very simple.

	angular.module("root", [])
		.value("message", "Hello world!");

Here we have defined a value called `message` which contains the string `"Hello world!"`. We pass the `message` value to a controller in the exact same way as we pass a `$scope`: We add the `"message"` string to the controller array, and finish off by adding a corresponding argument to the controller function.

	angular.module("root", [])
		.value("message", "Hello world!")
		.controller("controller", ["$scope", "message", function($scope, message) {
			// Do something with message and/or $scope.
		}]);
		

##Modules
While the code above is well on its way to becoming a modular, extensible Angular app, we can actually take all this one step further. The AngularJS team actually recommends that applications be split into several modules, defined according to the following logic.

+ Create one module for each feature
+ Create one module for each reusable component
+ Create an application level module which depends on the above modules and contains any initialization code.

In our case, we could split our app into one module containing value service, and one module containing the controller.

	// Root.js
	angular.module("root", [])
		.controller("controller", ["$scope", "message", function($scope, message) {
			// Do something with message and/or $scope.
		}]);

	// Services.js
	angular.module("services", [])
		.value("message", "Hello world!");

##More injection

The above code looks great. However, if we go ahead and run it, we will quickly see that we have a problem. The Angular dependency injector won't be able to inject the `message` service into the controller function. This is because by default the injector will not inject components from one module into components in another. More concretely, components defined in the `services` module are not available for use in the `root` module as far as the injector is concerned.

In order to tell the injector that we can reference components from `services`, we need to inject the `services` module into the `root` module like so.

	// Root.js
	angular.module("root", ["services"])
		.controller("controller", ["$scope", "message", function($scope, message) {
		// ...

Now, when the injector sees that we want to inject `message` into our controller function, it will look in the `services` module to see if it can find a match. Having to inject modules in this way is a great feature. Not only does it make it clear what a module depends on from the very first line of code, but it also helps prevent naming collisions.

##Example

For this example, try to replicate the code sample above, displaying the `message` in the HTML page provided by way of the `$scope`. You're pretty much on your own for this one. You have two empty .js files at your disposal, one for each module, and a bare HTML page where you will need to reference your controller *as well as your root module*. The exact steps you will need to take are as follows.

+ Declare a services module in `services.js` and create a value service named `message`.
+ Declare a root module in `root.js`, injecting your newly-created `services` module.
+ Create a controller in your root module. The controller should take a `$scope` and an instance of your `message` service.
+ Reference your root module in the HTML page.
+ Reference your controller in the HTML page.
+ Display the message on the page using the double curly brace syntax.

If you can complete this example successfully, you are well on your way to developing fully fledged Angular apps. If you have trouble, don't hesitate to click the "I'm Stuck!" button to see how it's done and try again.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header></Header>
          <Initial>
            <![CDATA[
<html>
  <body>
    <div></div>
  </body>
</html>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<html ng-app="root">
    <body>
        <div ng-controller="controller">{{message}}</div>
    </body>
</html>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[

            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["services"])
	.controller("controller", ["$scope", "message", function($scope, message) {
		$scope.message = message;
	}]);
            ]]>
          </Solution>
        </Document>
      <Document Name="services.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module("services", [])
	.value("message", "Hello world!");
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <!--<Module Id="module-enriching-applications" Title="Enriching Applications">
    <Lesson Id="validation-classes" Title="Validation Classes">
      <Instructions>
        <![CDATA[
By now you should have a basic understanding of how to build a simple Angular application and of the components which make up such an appliction. You should also be familiar with some of the core directives that are available in Angular that allow you to bind your template to your scope, making it dynamic and reactive to changes in the scope's underlying data.

We are now going to turn our attention to some of the core features that Angular provides us with that allow us to enrich our applications.

##Validation Attributes and CSS Classes...

AngularJS provides built-in support for data validation through the use of the following HTML attributes.

+ `required`
+ `pattern`
+ `minlength`
+ `maxlength`
+ `min`
+ `max`

To enable us to handle data validation correctly, Angular provides us with two pieces of information per form field.

+ Whether the field has been modified or not.
+ Whether the field is valid nor not.

It does this by applying a subset of the following CSS classes to each field.

+ `ng-valid`
+ `ng-invalid`
+ `ng-pristine`
+ `ng-dirty`

`ng-valid` and `ng-invalid` tell us whether or not a field's data has passed validation. `ng-pristine` and `ng-dirty` allow us to inform the user of field validity only if he/she has actually entered data in the field. We don't want to distract users by telling them that fields are invalid before they have even turned their attention to the fields in question.

##Example

We have three fields with three different validation rules. The first must contain a valid email address, the second must contain a number between 10 and 20, and the third must not be empty. You have two objectives for this example.

+ Apply `border: 2px solid red` to fields that have been modified and are invalid.
+ Apply `border: 2px solid green` to fields that have been modified and are valid.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<style>
/* Write your style rules here */
</style>
<form ng-controller="controller">
	<div>
	  Email: <input type="text" pattern="\S*@\S*\.\S*" ng-model="email" />
	</div>
	<div>
	  Age: <input type="text" min="18" ng-model="age" />
	</div>
	<div>
	  Favorite food: <input type="text" required ng-model="food" />
	</div>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<style>
.ng-valid.ng-dirty { border: 2px solid green; }
.ng-invalid.ng-dirty { border: 2px solid red; }
</style>
<form ng-controller="controller" class="css-controller">
	<div>
	  Email: <input type="text" pattern="\S*@\S*\.\S*" ng-model="email" />
	</div>
	<div>
	  Age: <input type="text" min="18" ng-model="age" />
	</div>
	<div>
	  Favorite food: <input type="text" required ng-model="food" />
	</div>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function($scope) {
		$scope.email = "";
		$scope.age = "";
		$scope.food = "";
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("controller", ["$scope", function($scope) {
		$scope.email = "";
		$scope.age = "";
		$scope.food = "";
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>-->
<!--<Module Id="" Title="Test Module">
    <Lesson Id="" Title="Empty Lesson">
      <Instructions>
        <![CDATA[

        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[

            ]]>
          </Header>
          <Initial>
            <![CDATA[

            ]]>
          </Initial>
          <Solution>
            <![CDATA[

            ]]>
          </Solution>
          <Footer>
            <![CDATA[

            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[

            ]]>
          </Initial>
          <Solution>
            <![CDATA[

            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>-->
</Course>